# 삼성 SW 역량 테스트 기출 문제 문제집 풀이

* [[17837]새로운 게임 2](https://www.acmicpc.net/problem/17837)
  * **구현**
  * 바닥 색, 각 칸의 마커 리스트, 마커 맵을 활용
  * 칸의 색을 확인하여 리스트를 움직여줌.
  * 바닥 색이 파란 색일 때, 반대 방향의 바닥 색을 다시 한 번 확인해줘야 함.
---
* [[17825]주사위 윷놀이](https://www.acmicpc.net/problem/17825)
  * **구현 / 브루트포스**
  * 이차원 배열로 윷놀이판(정수형), 현재 마커 존재 여부(boolean) 표시
  * 마커 위치를 담은 이차원 배열을 활용, 재귀 함수 호출
  * 4개의 말을 차례로 반복
    * 25번으로 가는 경우 / 도착하는 경우 / 그 외의 경우로 나누어 말 이동
---
* [[20061]모노미노도미노 2](https://www.acmicpc.net/problem/20061)
  * **구현**
  * 이차원 배열로 blue, green 보드판 설계, 블록을 쌓음
  * 블록 입력이 들어오면 위에서부터 확인하며 한 칸씩 내려 놓을 수 있는 위치를 찾음
    * 지금 놓인 블럭의 위치를 저장함(top)
  * 블록 위치에 놓은 뒤 행, 열 검사 > 점수 카운트
    * 해당 행/열을 없애고 한 줄씩 아래로 내림
    * top+=1
  * top 값에 따라 특별한 칸 처리
  * 모든 블록 연산 이후, 각 보드판에 남은 블럭 수를 계산
  * 점수와 남은 블럭 수 출력
---
* [[19236]청소년 상어](https://www.acmicpc.net/problem/19236)
  * **시뮬레이션, 재귀**
  * 물고기 번호를 저장하는 정수형 2차원 배열 space, 물고기 번호를 key/물고기 정보를 기록하는 Fish객체를 value로 하는 Map, fishMap 사용
  * 청소년 상어가 물고기를 먹는 함수(EatYouthShark)에서 청소년 상어 연산 실행
    * 원상 복구를 위한 deep copy
    * 1번~16번 물고기 번호 순서대로 이동시키는 moveFish 함수
    * 이동 칸 경우에 따라 물고기를 먹고, 그 상태에서 물고기를 계속 탐색하도록 재귀 호출
      * 호출된 함수 종료 시 space와 fishMap을 함수 호출 초기 상태로 원상복구
    * 함수 종료 시 먹은 물고기 원상 복구
---
* [[21609]상어 중학교](https://www.acmicpc.net/problem/21609)
  * **시뮬레이션 / BFS**
  * 현재 블록 상황을 표현하기 위한 2차원 정수형 배열 grid, 블록 그룹 우선순위 파악을 위한 우선순위 큐 candidates, 각 블록 그룹에 속한 블록들 좌표를 표현하기 위한 해쉬맵 groups 사용
  * (블록 그룹 찾기 > 점수획득(블록 삭제) > 중력 적용 > 회전 > 중력 적용)반복
  * bfs로 블록 그룹 찾기
    * (0, 0)부터 (N-1, N-1)까지 순서대로 탐색
    * visited되지 않은 블록들을 대상으로 탐색
    * 전체 블록 개수, 일반 블록 개수, 무지개 블록 개수 카운팅
    * 전체 블록 2개 이상, 일반 블록 1개 이상일 때 candidates, groups에 추가
  * 점수 획득
    * 가장 우선순위가 높은 그룹을 grid에서 없앰
    * 점수 추가
  * 중력 적용
    * (N-1, 0)부터 (0, N-1)까지 반복
    * tempGrid에 grid중력 적용한 블록을 적용
    * 기존 grid의 row를 표현하기 위한 정수 row와, 비어있지 않은 블록을 찾는 데에 쓰이는 nr을 사용하여 블록을 내려줌
  * 회전
    * (c, N-r-1) > (r, c)
---
* [[21611]마법사 상어와 블리자드](https://www.acmicpc.net/problem/21611)
  * **구현**
  * 현재 구슬 상황을 표현하는 2차원 정수형 배열 grid, 0이 아닌 구슬을 순서대로 가지고 있는 ballList 사용
  * (얼음 파편 던지기 > 구슬 움직이기 (연속 구슬 폭발 > 구슬 움직이기) 반복 > 구슬 변화시키기) 반복
  * 주어진 방향으로 주어진 길이만큼 구슬 파괴
  * 구슬 이동
    * 문제에서 주어진 것과 같이 상어를 중심으로 회전하며 0이 아닌 구슬을 ballList에 저장
    * ballList에 담긴 값을 순서대로 회전하며 grid에 다시 넣어줌
  * 연속 구슬 폭발
    * 문제에서 주어진 것과 같이 상어를 중심으로 회전하며 연속된 구슬 개수를 카운팅
    * 4개 이상 같은 번호가 연속되면 폭발
  * 구슬 변화
    * 문제에서 주어진 것과 같이 상어를 중심으로 회전하며 구슬 번호, 연속된 개수 카운팅, ballList에 저장
    * ballList에 담긴 값을 순서대로 회전하며 grid에 다시 넣어줌
  * 한 번 리스트에 넣었으면 그냥 순서대로 연속 구슬 개수 찾고, 구슬 변화까지 시켜줄 수 있었을 듯..? 
---
* [[23289]온풍기 안녕!](https://www.acmicpc.net/problem/23289)
  * **구현 / BFS**
  * 현재 방온도를 표현하는 2차원 정수형 배열 room, 4방향 벽 표현을 위한 2차원 논리형 배열 isWall, 온도를 확인해줘야 하는 칸을 저장한 checkSection, 온풍기 리스트 airList 사용
  * (온풍기 작동 > 온도 조절 > 외부 온도 감소 > 초콜릿 냠 > 온도 확인)반복
  * 온풍기 작동은 BFS로 구현
    * 온풍기 별로 반복
      * 가장 첫번째 칸(온도 5) 추가 후 시작
      * 3가지 방향(-1, 0, 1)으로 온도 확산
  * 온도 조절
    * (0, 0)부터 (R-1, C-1)까지 반복
      * 4방향 탐색, 나보다 온도가 낮은 친구와 조절
  * 외부 온도 감소
    * for문 두 번 사용
  * 온도 확인
    * checkSection 리스트 값을 탐색하며 K온도보다 낮은 구역이 있는 지 확인
---
* [[23290]마법사 상어와 복제](https://www.acmicpc.net/problem/23290)
  * **구현 / 브루트포스**
  * ArrayList 이차원 배열로 격자판, Deque 이차원 배열로 냄새 표현
  * (물고기 복사 > 물고기 이동 > 상어 이동 > 냄새 없애기 > 복사 완료) 반복
  * 물고기 복사
    * 전체 격자(4*4)돌면서 격자에 있는 물고기 리스트 fishList에 복사
  * 물고기 이동
    * 전체 격자(4*4)돌면서 8가지 방향을 탐색, 탐색 중 이동가능한 칸을 찾으면 이동
  * 상어 이동
    * 연속해서 3칸 이동 > 전체 경우의 수는 4방향*3칸 > 3중 for문
    * 이동 좌표 계산 후, 범위 체크
    * 첫번째 이동의 경우, 3번째 이동이 동일한 칸이 될 수 있으므로 물고기 카운팅을 위해 visited방문 처리
    * 마지막 이동에서 없앤 물고기 개수 비교
    * 가장 큰 경우로 상어 이동, 냄새 추가
  * 냄새 없애기
    * 전체 격자(4*4) 돌면서 현재 time과 냄새 칸의 냄새 비교
    * deque에 add로 붙여줬기 때문에, 자동으로 정렬되어 있음. 만약 사라지지 않는 냄새 확인 시 addFirst로 다시 맨 앞칸에 넣고 stop
  * 복사 완료
    * 복사했던 fishList에 있는 Fish를 격자에 추가
  * 전체 격자(4*4)돌면서 물고기 개수 카운팅, 출력
 ---
 * [[23291]어항 정리](https://www.acmicpc.net/problem/23291)
   * **구현 / 브루트포스**
   * 정수형 이차원 배열로 어항 표현
   * (물고기 현황 체크 > 새 물고기 추가 > 공중부양&회전 > 물고기 수 조절 > 한 줄로 어항 정렬 > 공중 부양 > 물고기 수 조절 > 한 줄로 어항 정렬) 반복
   * 물고기 현황 체크
     * 어항 최대 물고기 개수, 최소 물고기 개수 카운팅 후 비교. K이하면 false, 초과면 true로 반복 여부 갱신
   * 새 물고기 추가
     * 위에서 카운팅한 최소 물고기 개수를 참고. 어항을 탐색하며 최소 물고기 개수 일치 시 +1
   * 공중부양&회전
     * step 회전 단계, col 현재 열, w 너비, h 높이, nw 다음 너비, nh 다음 높이
     * 다음 높이*다음 넓이가 N보다 작거나 같은 경우까지만 반복
     * (N-1, col)~(N-1-h, col+w)까지 반복
     * nr = (N-1-w)+(c-col)
       * w는 이전 너비 == 이번 높이 >>N-1-w는 시작 행
       * c=col+x(x<w, 이전 열 위치 == 현재 행 위치) > c-col = col+x-col > x >> 현재 행 위치
     * nc = (col+w)+(N-1-r)
       * w는 이전 너비 > col(현재 열)+너비(추가로 뒤로 가야하는 너비) >> 시작 열
       * N-1-r = N-1-(N-1-y(y<h, 이전 행 위치 == 현재 열 위치) = N-1-N+1+y = y >> 현재 열 위치
   * 물고기 개체 조절
     * (N-1, N-1)~(0, 0)까지 반복
     * 현재 어항 물고기 수를 newFishbowl에 추가
     * 인접한 4방향 탐색하며 개체 수 조절
   * 한 줄 정렬
     * idx로 어항 순서 설정(초기값 0)
     * 열 순서대로(0~N-1) 탐색
     * 어항이 없으면(==물고기가 0이면) 다음 열로 넘겨줌
     * 어항이 있으면 (N-1~0)까지 행 탐색, 탐색 중 어항이 없으면 다음 열로 넘김
     * 존재하는 어항 [N-1][idx]에 삽입
   * 공중부양
     * 반으로 나눠 180도 회전 > 앞쪽의 반을 거꾸로 뒤집어 뒷 열에 한 줄 위로 이동
       * [N-1][c]  >이동>  [N-2][N-1-c] 
     * 열 카운팅을 위한 별도의 idx 설정(초기값 N-3)
       * [r][c] >이동> [idx--][(N-1)-(c-step)]
       * N-1-(c-step) > c-step = startC+nS-step = step+nS(nS<nStep, 현재 이동할 열)-step = nS >> (N-1)-nS == 마지막 줄로부터 nS번째 열 
